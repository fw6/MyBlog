[{"title":"Python 基础知识学习","date":"2018-11-20T13:21:10.000Z","path":"2018/11/20/Python-基础知识学习/","text":"Python 基础知识人生苦短，我学Python Python 语言已经在大数据、机器学习等领域胜出，这是毋庸置疑的事实了。它以简洁、优雅的语言风格征服了程序员和非专业程序员。并且，它还是一种非常容易学的语言。所以，学习 Python性价比最高。 以上是一堆废话。。。 变量和数据类型数据类型整数Python 可以处理任意大小的整数，自然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如1，100，-100，0，等等。计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如 $1.2310^9$ 和$12.310^8$是相等的，浮点数可以用数学写法，如1.23，3.14，-9.01等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e代替， 整数和浮点数在计算机内部存储方式是不同的，整数运算永远是准确的（除法？？？），而浮点数运算则可能会四舍五入误差。 字符串字符串是以&#39;&#39;或者&quot;&quot;括起来的任意文本，比如‘abc’、“xyz”等。请注意，‘’和“”本身自实一种表达方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只是a, b, c这三个字符。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，，在Python中，可以直接用True，False代表布尔值（大小写！），也可通过布尔运算计算出来。 布尔值可以用and、or和not运算。 布尔类型中的短路计算： 在计算a and b时，如果a是False，则根据与运算法则，整个结果必定为False，因此返回a；如果a是True，则整个计算结果必定取决于b，因此返回b。 在计算a or b时，如果a是True，则根据或计算规则，整个计算结果必定为True，因此返回a；如果a是False，则整个计算结果必定取决于b，因此返回b。 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型。 Raw字符串和多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀r，表示这是一个raw字符串，里面的字符就不需要转义了。 例如： 1print r'\\(~_~)/ \\(~_~)' 但是r&#39;...&#39;表示法不能表示多行字符串，也不能表示包含&#39;&#39;和&quot;&quot;的字符串 如果要表示多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 123'''Line 1Line 2Line3''' 同下： 1'Line 1\\nLine 2\\nLine 3' 还可以在多行字符串前面加r，把这个多行字符串也变成一个raw字符串 123r'''Python is created by \"Guido\".It is free and easy to learn.Let's start learn Python''' Unicode字符串因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串ABC在Python内部都是ASCII编码的。Python后来添加了对Unicode的支持，以Unicode表示的字符串用u&#39;...&#39;表示，比如1print u'中文' 转义：12u'''第一行第二行''' raw + 多行：123ur'''Python的Unicode字符串支持\"中文\",\"日文\",\"韩文\"等多种语言 123如果中文字符串在Python环境下遇到**UnicodeDecodeError**，这是因为.py文件保存的格式有问题。可以在第一行添加注释```python# -*- coding: utf-8 -*- 目的是告诉Python解释器，用UTF-8编码读取源代码 List和Tuple元组类型Python内置的一种数据类型是列表：List。List是一种有序的集合，可以随时添加和删除其中的元素。List是数学意义上的有序集合，也就是说，List中的元素是按照顺序排列的。 append添加新元素到尾部，ClassA.append(&#39;newBoy&#39;) insert添加元素到任意位置，ClassA.insert(0, &#39;anotherBoy&#39;) pop删除最后一个元素，可传索引定位删除 替换对List中的某个索引赋值，就可以直接替换掉原来的元素 Tuple是另一种有序列表，中文翻译为‘元组’。Tuple和List非常相似，但是Tuple一旦创建完毕，就不能修改了。1&gt;&gt;&gt; t = ('LiHua', 'HanMeimei', 'Lisa', 'Goudan') Tuple所谓的不变是说，Tuple的每一个元素，指向永远不变。即指向a(堆)，就不能指向b；指向List（栈），就不能指向其他对象，但指向的这个List本身是可变的 Tuple没有append()方法，也没有insert()和pop()方法。所以，新同学没法直接往Tuple里面添加，老同学想退出Tuple也不行。获取Tuple的方法同List[0] 创建空Tuple 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; print t() 创建单元素Tuple 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; print t1 这里t不是Tuple，而是整数1??? 因为()即可以表示Tuple，又可以表示括号运算时的优先级，结果(1)被Python解释器计算出结果1，导致我们得到的不是Tuple，而是整数1。 正是因为用()定义单元素的Tuple有歧义，所以Python规定，单元素Tuple要多加一个逗号”,”，这样就避免了歧义：123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; print t(1,) 条件判断和循环条件判断基本if语句实现：12345age = 20if age &gt;= 18: print 'your age is', age print 'adult'print 'END' 注意：if语句后接表达式，然后用:表示代码块开始。 如果在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进还要多敲一行回车：1234567&gt;&gt;&gt; age = 20&lt;&lt;&lt; if age &gt;= 18:··· print 'your age is', age··· print 'adult'···your age is 20adult if … else … 语句实现：1234if age &gt;= 18: print 'adult'else: print 'teenager' if … 多个elif … else …语句实现：12345678if age &gt;= 18: print 'adult'elif age &gt;= 6: print 'teenager'elif age &gt;= 3: print 'kid'else: print 'baby' 循环for循环语句：123L = ['LiHua', 'HanMeimei', 'Lisa', 'Goudan']for name in L: print name while循环语句：12345N = 10x = 0while x &lt; N: print x x++ 每次先判断 x &lt; N,如果为True，则执行循环体的代码块，否则退出循环 break跳出循环：在for循环或while循环时，使用break语句可直接跳出循环12345678sum = 0x = 1while True sum += x x++ if x &gt; 100: breakprint sum continue继续循环：跳过后续循环代码，继续下一次循环。统计几个分数的平均分12345678L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: if x &lt; 60: continue sum += x n++ 0-100只计算奇数的和：12345678910sum = 0n = 0while True: x += 1 if x &gt; 100: break if x % 2 == 1: sum += x continueprint sum Dict和Set类型DictDict类似与Javascript中的Object对象：12345d = &#123; 'LiHua': 95, 'Lisa': 85, 'Goudan': 59&#125; len()函数可计算任意集合的长度12&gt;&gt;&gt; len(d)3 访问Dict1234567&gt;&gt;&gt; print d['Lihua']95&gt;&gt;&gt; print d['ZhaoSi']Traceback (most recent call last): file \"index.py\", line 11, in &lt;module&gt; print d['ZhaoSi']KeyError: 'ZhaoSi' key不存在会报错，避免KeyError发生，有如下方法： 123456789# 判断 key 是否存在，用 in 操作符if 'ZhaoSi' in d: print d['ZhaoSi']# 用 Dict 自身提供的 get 方法&gt;&gt;&gt; print d.get('LiHua')95&gt;&gt;&gt; print d.get('ZhaoSi')None setset 持有一系列元素，这一点和list很像，但是 set 的元素没有重复，而且无序，这点和dict的key很像。 创建set1&gt;&gt;&gt; s = set(['A', 'B', 'C']) 可以查看set内容12&gt;&gt;&gt; print sset(['A', 'B', 'C']) in操作符判断元素12&gt;&gt;&gt; 'Bart' in sTrue 将set中的字母小写12&gt;&gt;&gt; print set([alp.lower() for alp in ['A', 'B', 'C']])set(['a', 'b', 'c']) 更新set由于set存储的是一组不重复的无序元素，因此，更新set只做两件事： 新增1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已经存在于set中，add()不会报错，也不会添加进去 删除1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果删除的元素不存在set中，remove()会报错。需要加判断 函数常用内置函数一、数学相关： 绝对值： abs(-1) 最大最小值：max([1, 2, 3])、min([1, 2, 3]) 序列长度：len(‘ABC’)、len([1, 2, 3])、len((1, 2, 3)) 取模：divmod(5, 2) –&gt; (2, 1) 乘方：pow(2, 3, 4) === 2 ** (3/4) 浮点数：round(1) –&gt; 1.0 二、功能相关 函数是否可调用：callable(func_name) 类型判断：isinstance(2, int) 比较：cmp(x, y) (python3.x已取消)x &lt; y (-1) | x == y (0) | x &gt; y (1) 快速生成序列：range(start, stop[, step])12&gt;&gt;&gt; range(0, 10, 3)[0, 3, 6, 9] 三、类型相关 int(x) 整型 long(x) 长整形 float(x) 浮点型 complex(x) 复数 str(x) list(x) tuple(x) 元组 hex(x) 10进制转换为16进制 oct(x) 整数转为8进制 chr(x) 返回编码x对应的字符 ord(x) 返回字符对应的ASC码 四、字符串处理 首字母大写 12&gt;&gt;&gt; 'hello'.capitalize()'Hello' 字符串替换 12&gt;&gt;&gt; 'hello'.replace('l', 'x')'hexxo' 第 3 个参数为替换次数 字符串切割12&gt;&gt;&gt; 'hello'.split('l')['he', 'o'] 第2个参数是切割次数 五、序列处理函数 len 序列长度 max 序列中最大值 min 序列中最小值 filter 过滤序列 12345&gt;&gt;&gt; def is_odd(n):··· return n % 2 == 1···&gt;&gt;&gt; print filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])[1, 3, 5, 7, 9] zip 并行遍历 12345&gt;&gt;&gt; name = ['Lily', 'Lisa', 'Roe']&gt;&gt;&gt; age = [18, 16, 17]&gt;&gt;&gt; tel = ['134', '156', '178']&gt;&gt;&gt; zip(name, age, tel)[('Lily', 18, '134'), ('Lisa', 16, '156'), ('Roe', 17, '178')] map 并行遍历，可接收function类型参数 1234&gt;&gt;&gt; a = [1, 3, 5]&gt;&gt;&gt; b = [2, 4, 6]&gt;&gt;&gt; map(None, a, b)[(1, 2), (3, 4), (5, 6)] reduce 归并 1234567&gt;&gt;&gt; def add(x, y) : # 两数相加... return x + y... &gt;&gt;&gt; reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+515&gt;&gt;&gt; reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数15 sum函数接受一个list作为参数，并返回list所有元素的和，请计算 1*1 + 2*2 + 3*3 + ... + 100*100123456789L = []i = 1while True: if i &gt; 100: break else: L.append(pow(i, 2)) i += 1print sum(L) 自定义函数12345def my_abs(x): if x &gt;= 0: return x else: return -x 定义一个square_of_sum函数，它接受一个list，返回list中每个元素平方的和。1234567def square_of_sum(L): count = 0 for item in L: count += pow(item, 2) return countprint square_of_sum([1, 2, 3, 4, 5]) 函数可返回多值：123456789import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y + step * math.sin(angle) return nx, nyx, y = move(100, 100, 60, math.pi / 6)print x, y# 151.961524227 70.0 多值返回其实是tuple！ 例子🌰：一元二次方程的定义是：$ax^2 + bx + c = 0$12345678import mathdef quadratic_equation(a, b, c): x1 = (-b + math.sqrt(pow(b, 2) - 4 * a * c)) / (2 * a) x2 = (-b - math.sqrt(pow(b, 2) - 4 * a * c)) / (2 * a) return x1, x2print quadratic_equation(2, 3, 0) 递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。举个栗子🌰：1fact(n) = n! = 1 * 2 * 3 * ... * n = (n - 1)! * n = fact(n - 1) * n 将fact(n)用递归的方式写出来即为：1234def fact(n): if n == 1: return 1 return n * fact(n - 1) 汉诺塔问题： 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 对柱子编号为a, b, c分别代表起始柱、帮忙柱、结束柱，编写函数打印出移动步骤1234567891011121314151617181920212223242526def hanoi(n, a, b, c): if n == 1: print a, '--&gt;', c else: hanoi(n - 1, a, c, b) print a, '--&gt;', c hanoi(n - 1, b, a, c)hanoi(4, 'A', 'B', 'C')'''A --&gt; BA --&gt; CB --&gt; CA --&gt; BC --&gt; AC --&gt; BA --&gt; BA --&gt; CB --&gt; CB --&gt; AC --&gt; AB --&gt; CA --&gt; BA --&gt; CB --&gt; C''' 默认参数12345678def greet(str = 'world'): print 'hello,' , str + '.'# hello, world.greet()# hello, Goudan.greet('Goudan') 可变形参12def fn(*args): print args 可变参数的名字前面有个*123456&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn('a')('a',)&gt;&gt;&gt; fn('a', 'b')('a', 'b') Python解释器会把传入的一组参数组装为一个tuple传递为可变参数，因此，在函数内部，直接把变量args看成一个tuple就好了🙆‍ 举个栗子🌰：计算平均值123456789def average(*args): l = len(args) count = 0.0 if l == 0: return count else: for item in args: count += item return count / l 切片截取一个list的部分元素，python提供切片(Slice)操作符123&gt;&gt;&gt; L = ['LiHua', 'Lisa', 'HanMeimei', 'Goudan', 'ZhaoSi']&gt;&gt;&gt; L(0:3)['LiHua', 'Lisa', 'HanMeimei'] L(0:3)表示，从索引0开始取，直到索引3为止。 如果第一个索引是0，可省略不写只用:，表示从头到尾 切片操作还可以指定第三个参数：12&gt;&gt;&gt; L[::2]['LiHua', 'HanMeimei', 'ZhaoSi'] 第三个参数表示每N个取一个 举个栗子🌰：取出1-100的 前10个数 3的倍数 不大于50的5的倍数 最后10个数 最后10个5的倍数12345678L = range(1, 101)print Lprint L[2::3]print L[4:50:5]print L[-10:]print L[4::5][-10:] 对字符串切片123456&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[-3:]'EFG'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 迭代迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用for循环总可以依次取出集合的每一个元素 注意：集合是指包含一组元素的数据结构，包括： 有序集合：list，tuple，str和unicode 无序集合：set 无序集合并且具有key-value对：dict 栗子🌰：打印出1-100中7的倍数123for i in range(1, 101): if not i % 7: print i 索引迭代Python中，迭代永远是取出元素本身，而非元素索引。对于有序集合使用enumerate函数拿到索引1234567&gt;&gt;&gt; L = ['LiHua', 'Lisa', 'HanMeimei']&gt;&gt;&gt; for index, name in enumerate(L):··· print index, '-', name···0 - LiHua1 - Lisa2 - HanMeimei 实际上，enumerate函数把[&#39;LiHua&#39;, &#39;Lisa&#39;, &#39;HanMeimei&#39;]变成了类似:[(0, &#39;LiHua&#39;), (1, &#39;Lisa&#39;), (2, &#39;HanMeimei&#39;)] 因此，迭代的每一个元素实际上是Tuple：1234for t in enumerate(L): index = t[0] name = t[1] print index, '-', name 举个西红柿🍅：迭代打印出名次 - 名字，名次从 1 开始123456789L = ['LiHua', 'Lisa', 'HanMeimei', 'Gudan']for index, name in zip(range(1, len(L) + 1), L): print index, '-', name1 - LiHua2 - Lisa3 - HanMeimei4 - Goudan 迭代Dict的valuedict对象中有一个values()方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是dict的每一个value1234567891011d = &#123;'LiHua': 95, 'Lisa': 85, 'HanMeimei': 89&#125;print d.values()# [95, 85, 89]for v in d.values(): print v'''958589''' dict除了values()方法外，还有一个intervalues()方法（Python3.x删除）1234567891011d = &#123;'LiHua': 95, 'Lisa': 85, 'HanMeimei': 89&#125;print d.intervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.intervalues(): print v'''958589''' 两者不同之处： values()方法实际上把一个dict转换成了包含value的list 但是intenvalues()方法不会转换，它会在迭代规程中取出value，所以intervalues()要比values()节省了生成了list的内存 打印intenvalues()返回值是&lt;dictionary-valueiterator&gt;对象， 迭代key、value123&gt;&gt;&gt; d = &#123;'LiHua': 95, 'Lisa': 85, 'HanMeimei': 89&#125;&gt;&gt;&gt; print d.items()[('LiHua', 95), ('Lisa', 85), ('HanMeimei', 89)] items()方法把dict对象转换成了包含tuple的list，对list进行迭代可同时获得key和value 123456789&gt;&gt;&gt; for key, value in d.items():··· print key, '-', value···'''LiHua - 95Lisa - 85HanMeimei - 89''' 和values()有一个itervalues()类似，items()也有一个对应的iteritems()（Python3废止），iteritems()不把dict转换为list，而是在迭代过程中不断给出tuple，所以iteritems()不占用额外内存。 列表生成式生成列表要生成list[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，可以用range(1, 11)12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但生成[1*1, 2*2, 3*3, 4*4, 5*5, 6*6, 7*7, 8*8, 9*9, 10*10]要怎么做呢？方法一：循环123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):··· L.append(x*x)···&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替：12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式举个西瓜🍉：利用列表生成式生成列表[1 2, 3 4, 5 6, …, 99 100]1&gt;&gt;&gt; print [x * (x - 1) for x in range(1, 100, 2)] 复杂表达式假设有如下dict：1d = &#123;'LiHua': 95, 'Lisa': 85, 'HanMeimei': 89&#125; 完全可以通过复杂的列表生成式变为html表格：12345tds = ['&lt;tr&gt;&lt;tds&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.items()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Value&lt;/td&gt;&lt;/tr&gt;'print '\\n'.join(tds)print '&lt;/table&gt;' 字符串可以通过%进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个list拼接成一个字符串。 条件过滤列表生成式的for循环后面还可以加上if判断只要偶数的平方12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 举个锤子🔨：将list中所有字符串变为大写后返回，忽略非字符串12345def toUppers(L): return [x.upper() for x in L if isinstance(x, str)]print toUppers(['Hello', 'world', 101])# ['HELLO', 'WORLD'] 多层表达式for循环可以嵌套，因此在列表生成式中，也可以用多层for循环生成；列表12&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 举个热狗🌭：利用三层循环找出对称的3位数。例如，121就是对称数，因为从右到左倒过来还是121。 方法一、双层循环1&gt;&gt;&gt; print [m * 100 + n * 10 + m for m in range(1, 10) for n in range(0, 10) 方法二、取模求商1&gt;&gt;&gt; print [m for m in range(100, 1000) if m / 100 == a % 10]"},{"title":"菜根谭","date":"2018-11-19T11:55:22.000Z","path":"2018/11/19/菜根谭/","text":"谭者，谈也。性定菜根香。 凭意兴做为随作随止，岂是不退之轮？从情识解悟者，有悟则有迷，终非常明之灯。 昔日所云我，而今却是伊。不知今日我，又属后来谁？ 衮冕行中，著一藜杖山人，便增一段高风；渔樵路上，著一衮衣朝士，转添许多俗气。固知浓不如淡，俗不胜雅。"},{"title":"Hello World","date":"2018-11-13T03:09:00.000Z","path":"2018/11/13/hello-world/","text":"Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server -d More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment hexo-admin-qiniulocalhost:4000/admin"}]